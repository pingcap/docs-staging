---
title: SQL
summary: TiDB の SQL 概念について学習します。
---

# 構文 {#sql}

TiDB は、MySQL プロトコル、およびMySQL 5.7と MySQL 8.0 の共通機能と構文と高い互換性があります。MySQL のエコシステム ツール (PHPMyAdmin、Navicat、MySQL Workbench、DBeaver、 [もっと](https://docs.pingcap.com/tidb/v7.2/dev-guide-third-party-support#gui) ) と MySQL クライアントを TiDB に使用できます。

ただし、MySQL の一部の機能は TiDB ではサポートされていません。これは、問題を解決するよりよい方法が存在する (XML関数の代わりに JSON を使用するなど) か、必要な労力に対して現在の需要が不足している (ストアド プロシージャや関数など) ことが原因である可能性があります。また、一部の機能は分散システムで実装するのが難しい場合があります。詳細については、 [MySQL 互換性](/mysql-compatibility.md)参照してください。

## SQL文 {#sql-statements}

SQL ステートメントは、識別子、パラメータ、変数、データ型、および予約済みの SQL キーワードで構成される SQL (構造化クエリ言語) のコマンドまたは命令です。SQL ステートメントは、データやデータベース構造の取得、変更、管理などの特定のアクションを実行するようにデータベースに指示します。

TiDB は、必要に応じて MySQL および TiDB 固有のステートメントの拡張機能を使用して、ISO/IEC SQL 標準に準拠することを目的とした SQL ステートメントを使用します。

SQL は関数に応じて次の 4 つのタイプに分けられます。

-   DDL (データ定義言語): データベース、テーブル、ビュー、インデックスなどのデータベース オブジェクトを定義するために使用されます。TiDB の DDL ステートメントについては、 [スキーマ管理 / データ定義ステートメント (DDL)](/sql-statements/sql-statement-overview.md#schema-management--data-definition-statements-ddl)参照してください。

-   DML (データ操作言語): アプリケーション関連のレコードを操作するために使用されます。TiDB の DML ステートメントについては、 [データ操作ステートメント (DML)](/sql-statements/sql-statement-overview.md#data-manipulation-statements-dml)参照してください。

-   DQL (データ クエリ言語): 条件付きフィルタリング後にレコードをクエリするために使用されます。

-   DCL (データ制御言語): アクセス権限とセキュリティ レベルを定義するために使用されます。

TiDB の SQL ステートメントの概要については、 [SQL ステートメントの概要](/sql-statements/sql-statement-overview.md)参照してください。

## SQL モード {#sql-mode}

TiDB サーバーはさまざまな SQL モードで動作し、クライアントごとに異なるモードでこれらのモードを適用します。SQL モードは、TiDB がサポートする SQL 構文と、実行するデータ検証チェックのタイプを定義します。

詳細については[SQL モード](/sql-mode.md)参照してください。

## 行ID生成属性 {#row-id-generation-attributes}

TiDB は、行 ID の生成とデータ分散を最適化するための 3 つの SQL 属性を提供します。

-   自動インクリメント

-   自動ランダム

-   シャード行IDビット

### 自動インクリメント {#auto-increment}

`AUTO_INCREMENT`は、デフォルトの列値を自動的に入力するために使用される列属性です。 `INSERT`ステートメントで`AUTO_INCREMENT`列の値が指定されていない場合、システムはこの列に値を自動的に割り当てます。

パフォーマンス上の理由から、各 TiDBサーバーには`AUTO_INCREMENT`数値が値のバッチで割り当てられます (デフォルトでは 3 万)。つまり、 `AUTO_INCREMENT`数値は一意であることが保証されますが、 `INSERT`ステートメントに割り当てられる値は TiDBサーバーごとに単調になります。

すべての TiDB サーバーで`AUTO_INCREMENT`数値を単調にしたい場合、および TiDB バージョンが v6.5.0 以降である場合は、 [MySQL互換モード](/auto-increment.md#mysql-compatibility-mode)を有効にすることをお勧めします。

詳細については[自動インクリメント](/auto-increment.md)参照してください。

### 自動ランダム {#auto-random}

`AUTO_RANDOM` 、 `BIGINT`列に値を自動的に割り当てるために使用される列属性です。自動的に割り当てられる値はランダムかつ一意です。値`AUTO_RANDOM`はランダムかつ一意であるため、TiDB が連続した ID を割り当てることによって単一のstorageノードに書き込みホットスポットが発生するのを回避するために、 [`AUTO_INCREMENT`](/auto-increment.md)の代わりに`AUTO_RANDOM`が使用されることがよくあります。

`AUTO_RANDOM`の値はランダムかつ一意であるため、TiDB が連続した ID を割り当てることによって単一のstorageノードに書き込みホットスポットが発生するのを避けるために、 [`AUTO_INCREMENT`](/auto-increment.md)の代わりに`AUTO_RANDOM`が使用されることがよくあります。現在の`AUTO_INCREMENT`列が主キーで、タイプが`BIGINT`場合、 `ALTER TABLE t MODIFY COLUMN id BIGINT AUTO_RANDOM(5);`ステートメントを実行して`AUTO_INCREMENT`から`AUTO_RANDOM`に切り替えることができます。

詳細については[自動ランダム](/auto-random.md)参照してください。

### シャード行IDビット {#shard-row-id-bits}

クラスター化されていない主キーを持つテーブル、または主キーのないテーブルの場合、TiDB は暗黙的な自動増分行 ID を使用します。 `INSERT`操作が大量に実行されると、データは単一のリージョンに書き込まれ、書き込みホットスポットが発生します。

ホットスポットの問題を軽減するには、 [`SHARD_ROW_ID_BITS`](/shard-row-id-bits.md)設定します。行 ID が分散され、データが複数の異なるリージョンに書き込まれます。

## キーワード {#keywords}

キーワードは、 `SELECT` 、 `UPDATE` 、 `DELETE`など、SQL ステートメントで特別な意味を持つ単語です。

-   そのうちのいくつかは識別子として直接使用することができ、非予約キーワードと呼ばれます。

-   識別子として使用する前に特別な処理が必要なキーワードもあり、これらは予約キーワードと呼ばれます。

ただし、予約されていないキーワードでも特別な処理が必要なものがあります。予約キーワードとして扱うことをお勧めします。

詳細については[キーワード](/keywords.md)参照してください。

## ユーザー定義変数 {#user-defined-variables}

TiDB を使用すると、ユーザー定義変数を設定および読み取ることができます。ユーザー定義変数の形式は`@var_name`です。 `var_name`構成する文字は、数字`0-9` 、文字`a-zA-Z` 、アンダースコア`_` 、ドル記号`$` 、UTF-8 文字など、識別子を構成できる任意の文字にすることができます。さらに、英語のピリオド`.`も含まれます。ユーザー定義変数は大文字と小文字を区別しません。

ユーザー定義変数はセッション固有であるため、1 つのクライアント接続で定義されたユーザー変数は、他のクライアント接続では表示または使用できません。

詳細については[ユーザー定義変数](/user-defined-variables.md)参照してください。

## メタデータロック {#metadata-lock}

TiDB では、メタデータ ロックは、オンライン スキーマ変更中にテーブル メタデータへの変更を管理するために導入されたメカニズムです。トランザクションが開始されると、現在のメタデータのスナップショットがロックされます。トランザクション中にメタデータが変更されると、TiDB は「情報スキーマが変更されました」というエラーをスローし、トランザクションのコミットを防止します。メタデータ ロックは、DML を優先することでデータ操作言語 (DML) とデータ定義言語 (DDL) の操作を調整し、古いメタデータを含む進行中の DML トランザクションが新しい DDL 変更を適用する前にコミットされるようにすることで、エラーを最小限に抑え、データの一貫性を維持します。

詳細については[メタデータロック](/metadata-lock.md)参照してください。

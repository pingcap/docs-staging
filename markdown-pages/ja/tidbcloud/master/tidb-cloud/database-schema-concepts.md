---
title: Database Schema
summary: TiDB Cloudのデータベース スキーマの概念について学習します。
---

# データベーススキーマ {#database-schema}

データベース スキーマは、データベース、テーブル、列、インデックス、およびその他のオブジェクト内のデータの構造と構成を定義します。

このドキュメントでは、データベース、テーブル、列、データ型、制約、インデックスなどのデータベース スキーマの主要な概念について説明します。また、中間データをシームレスに管理するための一時テーブル、効率的な近似最近傍 (ANN) 検索のためのベクター インデックス、読み取りパフォーマンスを向上させるキャッシュ テーブルなどの高度な機能についても説明します。

## データベース {#databases}

TiDB のデータベースは、テーブルやインデックスなどのオブジェクトのコレクションです。

### システムデータベース {#system-databases}

システム データベースは、システム テーブルを格納するために TiDB によって作成されるデフォルトのデータベースです。TiDB は次のシステム データベースを提供します。

-   [`INFORMATION_SCHEMA`](/information-schema/information-schema.md)

-   [`mysql`](/mysql-schema/mysql-schema.md)

-   [`performance_schema`](/performance-schema/performance-schema.md)

-   [`sys`](/sys-schema/sys-schema.md)

### <code>test</code>データベース {#code-test-code-database}

TiDB には`test`という名前のデフォルトのデータベースが付属しています。ただし、 `test`データベースを使用するのではなく、独自のデータベースを作成することをお勧めします。

## テーブル {#tables}

テーブルは、 [データベース](/develop/dev-guide-schema-design-overview.md#database)内の関連データの集合です。

各テーブルは行と列で構成されています。行内の各値は特定の列に属します。各列では 1 つのデータ型のみが許可されます。列をさらに限定するには、 [制約](/constraints.md)追加できます。計算を高速化するには、 [生成された列](/generated-columns.md)追加できます。

### システムテーブル {#system-table}

-   `mysql`スキーマには、TiDB システム テーブルが含まれています。設計は MySQL の`mysql`スキーマに似ており、 `mysql.user`などのテーブルを直接編集できます。また、MySQL の拡張機能であるテーブルもいくつか含まれています。

-   情報スキーマは、システム メタデータを表示するための ANSI 標準の方法を提供します。TiDB は、MySQL 互換性のために含まれているテーブルに加えて、多数のカスタム`INFORMATION_SCHEMA`テーブルも提供します。多くの`INFORMATION_SCHEMA`テーブルには、対応する`SHOW`コマンドがあります`INFORMATION_SCHEMA`クエリする利点は、テーブル間の結合が可能であることです。

-   パフォーマンス スキーマ。TiDB は、MySQL との互換性のためにパフォーマンス スキーマ テーブルを実装します。

### キャッシュされたテーブル {#cached-table}

TiDB は、頻繁にアクセスされるが、めったに更新されない小さなホットスポット テーブル向けに[キャッシュされたテーブル](/cached-tables.md)機能を導入しています。この機能を使用すると、テーブル全体のデータが TiDBサーバーのメモリにロードされ、TiDB は TiKV にアクセスせずにメモリからテーブル データを直接取得するため、読み取りパフォーマンスが向上します。

### 一時テーブル {#temporary-table}

一時テーブル機能は、アプリケーションの中間結果を一時的に保存するという問題を解決し、テーブルを頻繁に作成したり削除したりする手間を省きます。中間計算データは一時テーブルに保存できます。中間データが不要になると、TiDB は一時テーブルを自動的にクリーンアップしてリサイクルします。これにより、ユーザー アプリケーションが複雑になりすぎることがなくなり、テーブル管理のオーバーヘッドが削減され、パフォーマンスが向上します。

### パーティションテーブル {#partitioned-table}

TiDB では、 [パーティション分割](/partitioned-table.md)使用すると、大きなテーブルをパーティションと呼ばれる 1 つ以上の管理しやすい部分に分割できます。各パーティションは独立しており、個別に管理できます。

## コラム {#columns}

列はテーブルに従属します。各テーブルには少なくとも 1 つの列があります。列は、各行の値を単一のデータ型の小さなセルに分割することで、テーブルに構造を提供します。

詳細については[列を定義する](/develop/dev-guide-create-table.md#define-columns)参照してください。

## 生成された列 {#generated-columns}

TiDB を使用すると、JSON データ型からデータを[生成された列](/generated-columns.md)として抽出できます。

一般的な列とは異なり、生成された列の値は列定義内の式によって計算されます。生成された列を挿入または更新する場合、値を割り当てることはできず、 `DEFAULT`のみを使用できます。

生成列には、仮想生成列と保存列の 2 種類があります。仮想生成列はstorageを占有せず、読み取られるときに計算されます。保存列は、書き込まれる (挿入または更新される) ときに計算され、storageを占有します。仮想生成列と比較すると、保存列は読み取りパフォーマンスが優れていますが、より多くのディスク領域を占有します。

## データ型 {#data-types}

TiDB は、 `SPATIAL`型を除く MySQL のすべてのデータ型をサポートしています。これには、 [数値型](/data-type-numeric.md) 、 [文字列型](/data-type-string.md) 、 [日付と時刻の種類](/data-type-date-and-time.md) 、および[JSON型](/data-type-json.md)のすべてが含まれます。

## インデックス {#indexes}

インデックスは、テーブル内の選択された列のコピーです。 [テーブル](/develop/dev-guide-schema-design-overview.md#table)の 1 つ以上の列を使用してインデックスを作成できます。 インデックスを使用すると、TiDB はテーブル内のすべての行を毎回検索しなくてもデータをすばやく見つけることができるため、クエリのパフォーマンスが大幅に向上します。

一般的なインデックスには次の 2 つの種類があります。

-   主キー: 主キー列のインデックス。

-   セカンダリインデックス: 主キー以外の列のインデックス

### ユニークなインデックス {#unique-indexes}

TiDB の一意のインデックスは、1 つ以上の列に一意性を強制し、テーブル内の 2 つの行がインデックス列に同じ値を持たないようにします。この制約により、重複する値を防ぐことでデータの整合性を維持する方法が提供され、一意のインデックスは、電子メール アドレス、ユーザー名、製品コードなど、自然に一意である必要があるフィールドに最適です。

### 主キーインデックス {#primary-key-index}

主キー インデックスは、テーブル内の 1 つ以上の列に対する一意のインデックスであり、各行の主識別子として機能します。TiDB では、すべてのテーブルに主キーが必要です。主キーは、ユーザーが明示的に定義することも、主キーが指定されていない場合は TiDB によって暗黙的に定義することもできます。

### 複合指数 {#composite-index}

複合インデックスは、テーブルの 2 つ以上の列に基づいて構築されるインデックスで、複数のフィールドでデータをフィルタリングまたは並べ替えるクエリに特に役立ちます。たとえば、person テーブルの`last_name`と`first_name`に複合インデックスを作成すると、TiDB は両方の名前に基づいてレコードをすばやく見つけることができます。

### 目に見えないインデックス {#invisible-indexes}

非表示のインデックスは、データベース内に存在するものの、クエリ オプティマイザーからは隠されており、クエリ プランでは無視されます。TiDB では、非表示のインデックスはテストやデバッグに役立ち、インデックスを完全に削除せずにパフォーマンスへの影響を評価できます。

TiDB v8.0.0 以降では、 [`tidb_opt_use_invisible_indexes`](/system-variables.md#tidb_opt_use_invisible_indexes-new-in-v800)システム変数を変更することで、オプティマイザーが非表示のインデックスを選択するようにすることができます。

### クラスター化インデックス {#clustered-indexes}

クラスター化インデックスでは、クラスター化という用語は、連携して動作するデータベース サーバーのグループではなく、データの格納方法の構成を指します。一部のデータベース管理システムでは、クラスター化インデックスをインデックス構成テーブル (IOT) と呼びます。

この機能は、主キーを含むテーブルにデータを格納する方法を制御します。この機能により、TiDB は特定のクエリのパフォーマンスを向上できる方法でテーブルを整理できるようになります。

詳細については[クラスター化インデックス](/clustered-indexes.md)参照してください。

### セカンダリインデックス {#secondary-index}

セカンダリ インデックスは、TiDB クラスター内の論理オブジェクトです。これは、クエリ パフォーマンスを向上させるために TiDB が使用するデータの並べ替えタイプと見なすことができます。TiDB では、セカンダリ インデックスの作成はオンライン操作であり、テーブルでのデータの読み取りおよび書き込み操作をブロックしません。各インデックスについて、TiDB はテーブル内の各行の参照を作成し、データではなく選択した列で参照を並べ替えます。

セカンダリインデックスの詳細については、 [セカンダリインデックス](https://docs.pingcap.com/tidb/stable/tidb-best-practices#secondary-index)参照してください。

TiDB では、 [既存のテーブルにセカンダリインデックスを追加する](/develop/dev-guide-create-secondary-indexes.md#add-a-secondary-index-to-an-existing-table)または[新しいテーブルを作成するときにセカンダリインデックスを作成する](/develop/dev-guide-create-secondary-indexes.md#create-a-secondary-index-when-creating-a-new-table)いずれかを選択できます。

### ベクトルインデックス {#vector-index}

次の TiDB デプロイメント オプションでは、TiDB はベクター データ型とベクター検索インデックスをサポートします。

-   TiDB Cloudサーバーレス

-   TiDB Self-Managed v8.4.0 以降のバージョン

TiDB では、ベクター インデックスは、ベクター データを含む列に対する効率的な近似最近傍 (ANN) 検索用に設計された特殊なインデックスです。ベクター インデックス、特に HNSW (Hierarchical Navigable Small World) アルゴリズムを使用すると、K 近傍 (KNN) 検索によって、ベクター空間内の最も近いデータ ポイントをすばやく識別できます。これにより、クエリのパフォーマンスが大幅に向上し、総当たり方式と比較して数ミリ秒で結果を得ることができます。

ベクター インデックスは、データのstorageと検索機能のためにTiFlashレプリカに依存します。ベクター インデックスを作成して使用する前に、クラスターでTiFlashノードが使用可能であることを確認してください。

## 制約 {#constraints}

TiDB は MySQL とほぼ同じ制約をサポートします。

### NOT NULL制約 {#not-null-constraints}

`NOT NULL`制約により、列に`NULL`値を含めることはできません。

列が`NOT NULL`制約で定義されている場合、TiDB では、その列に`NULL`値を持つ行を挿入または更新しようとするとエラーが発生します。この動作は、MySQL の`NOT NULL`制約の実装と一致しています。

### CHECK制約 {#check-constraints}

`CHECK`制約は、テーブル内の列の値を、指定した条件を満たすように制限します。3 制約がテーブルに追加される`CHECK` 、TiDB はテーブルへのデータの挿入または更新中に制約が満たされているかどうかを確認します。制約が満たされていない場合は、エラーが返されます。

### 主キー制約 {#primary-key-constraints}

MySQL と同様に、TiDB の主キー制約には一意制約が含まれています。つまり、主キー制約を作成することは、一意制約を持つことと同じです。また、TiDB のその他の主キー制約も MySQL のものと似ています。

### ユニークキー制約 {#unique-key-constraints}

一意制約とは、一意のインデックスと主キー列内のすべての NULL 以外の値が一意であることを意味します。

### FOREIGN KEY制約 {#foreign-key-constraints}

FOREIGN KEY は、1 つのテーブル (子テーブル) の列を別のテーブル (親テーブル) の列にリンクすることで、2 つのテーブル間の参照整合性を強制するデータベース制約です。これにより、子テーブルの外部キー列の値が、親テーブルの主キー列または一意のキー列の値と一致することが保証されます。たとえば、 `orders`テーブルのレコードには、 `customers`テーブルの顧客にリンクする外部キーがあり、各注文が有効な顧客に関連付けられていることが保証されます。

v6.6.0 以降、TiDB は外部キー制約を実験的機能としてサポートしています。この機能により、関連データのテーブル間参照が可能になり、参照整合性を強制することでデータの一貫性を維持できます。ただし、この機能は実験的であり、特に大量のデータがある場合にパフォーマンスの問題が発生する可能性があるため、本番環境では推奨されないことに注意してください。

詳細については[FOREIGN KEY制約](/foreign-key.md)参照してください。

## ビュー {#views}

ビューは仮想テーブルとして機能し、そのスキーマはビューを作成する`SELECT`のステートメントによって定義されます。ビューを使用すると、次の利点があります。

-   安全なフィールドとデータのみをユーザーに公開し、基になるテーブルに保存されている機密フィールドとデータのセキュリティを確保します。

-   頻繁に表示される複雑なクエリをビューとして定義し、複雑なクエリをより簡単に、より便利にします。

詳細については[ビュー](/views.md)参照してください。

## シーケンス {#sequence}

シーケンスは、指定された一連のルールに従って一連の数字を生成するように設計されたデータベース オブジェクトです。この機能は、データベース テーブルの主キーの作成など、一意の識別子が必要なシナリオで特に役立ちます。

詳細については[順序](/sql-statements/sql-statement-create-sequence.md)参照してください。

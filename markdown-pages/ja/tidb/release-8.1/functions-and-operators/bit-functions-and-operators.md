---
title: Bit Functions and Operators
summary: ビット関数と演算子について学びます。
---

# ビット関数と演算子 {#bit-functions-and-operators}

TiDB は、MySQL 8.0 で利用可能な[ビット関数と演算子](https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html)のすべてをサポートします。

**ビット関数と演算子:**

| 名前                             | 説明                  |
| :----------------------------- | :------------------ |
| [`BIT_COUNT()`](#bit_count)    | 1に設定されているビットの数を返します |
| [`&#x26;`](#-bitwise-and)      | ビットAND              |
| [`~`](#-bitwise-inversion)     | ビット反転               |
| [`|`](#-bitwise-or)            | ビットOR               |
| [`^`](#-bitwise-xor)           | ビット単位の排他的論理和        |
| [`&#x3C;&#x3C;`](#-left-shift) | 左シフト                |
| [`>>`](#-right-shift)          | 右シフト                |

## <a href="https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#function_bit-count"><code>BIT_COUNT()</code></a> {#a-href-https-dev-mysql-com-doc-refman-8-0-en-bit-functions-html-function-bit-count-code-bit-count-code-a}

`BIT_COUNT(expr)`関数は、 `expr`のうち 1 に設定されているビットの数を返します。

```sql
SELECT BIT_COUNT(b'00101001');
```

    +------------------------+
    | BIT_COUNT(b'00101001') |
    +------------------------+
    |                      3 |
    +------------------------+
    1 row in set (0.00 sec)

> **注記：**
>
> 引数`expr`が 2 進数の場合、 `b'00101001'`のように数値の前に`b`明示的に指定する必要があります。そうしないと、この関数はそれを文字列として扱い、異なる結果を返します。たとえば、 `BIT_COUNT('00101001')`文字列`'00101001'` 10 進数`101001`に変換し、その 2 進形式`11000100001010001`で`1`ビットの数をカウントするため、 `7`返します。

次の例は前の例と似ていますが、引数としてビットリテラルではなく`CONV()`進リテラルを使用しています。1 関数は`0x29` 16 進数 (基数 16) から 2 進数 (基数 2) に変換し、2 進数では`00101001`に等しいことを示します。

```sql
SELECT BIT_COUNT(0x29), CONV(0x29,16,2);
```

    +-----------------+-----------------+
    | BIT_COUNT(0x29) | CONV(0x29,16,2) |
    +-----------------+-----------------+
    |               3 | 101001          |
    +-----------------+-----------------+
    1 row in set (0.01 sec)

`BIT_COUNT(expr)`関数の実際的な使用法は、ネットマスクを[CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)表記に変換することです。次の例では、ネットマスク`255.255.255.0`が CIDR 表現`24`に変換されます。

```sql
SELECT BIT_COUNT(INET_ATON('255.255.255.0'));
```

    +---------------------------------------+
    | BIT_COUNT(INET_ATON('255.255.255.0')) |
    +---------------------------------------+
    |                                    24 |
    +---------------------------------------+
    1 row in set (0.00 sec)

## <a href="https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-and"><code>&amp;</code> (ビットAND)</a> {#a-href-https-dev-mysql-com-doc-refman-8-0-en-bit-functions-html-operator-bitwise-and-code-x26-code-bitwise-and-a}

`&`演算子はビット単位の AND 演算を実行します。2 つの数値の対応するビットを比較します。対応するビットが両方とも 1 の場合、結果の対応するビットは 1 になります。それ以外の場合は 0 になります。

たとえば、 `1010`と`1100`ビット単位の AND 演算では、両方の数値で左端のビットのみが 1 に設定されているため、 `1000`が返されます。

      1010
    & 1100
      ----
      1000

SQL では、 `&`演算子を次のように使用できます。

```sql
SELECT CONV(b'1010' & b'1000',10,2);
```

    +------------------------------+
    | CONV(b'1010' & b'1000',10,2) |
    +------------------------------+
    | 1000                         |
    +------------------------------+
    1 row in set (0.00 sec)

`&`演算子を`INET_NTOA()`および`INET_ATON()`関数と共に使用して、IP アドレスとネットワーク マスクに対してビット単位の AND 演算を実行し、ネットワーク アドレスを取得できます。これは、複数の IP アドレスが同じネットワークに属しているかどうかを判断するのに役立ちます。

次の 2 つの例では、 IP アドレス`192.168.1.1`と`192.168.1.2` `255.255.255.0`でマスクされている場合、同じネットワーク`192.168.1.0/24`内にあります。

```sql
SELECT INET_NTOA(INET_ATON('192.168.1.1') & INET_ATON('255.255.255.0'));
```

    +------------------------------------------------------------------+
    | INET_NTOA(INET_ATON('192.168.1.1') & INET_ATON('255.255.255.0')) |
    +------------------------------------------------------------------+
    | 192.168.1.0                                                      |
    +------------------------------------------------------------------+
    1 row in set (0.00 sec)

```sql
SELECT INET_NTOA(INET_ATON('192.168.1.2') & INET_ATON('255.255.255.0'));
```

    +------------------------------------------------------------------+
    | INET_NTOA(INET_ATON('192.168.1.2') & INET_ATON('255.255.255.0')) |
    +------------------------------------------------------------------+
    | 192.168.1.0                                                      |
    +------------------------------------------------------------------+
    1 row in set (0.00 sec)

## <a href="https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-invert"><code>~</code> (ビット反転)</a> {#a-href-https-dev-mysql-com-doc-refman-8-0-en-bit-functions-html-operator-bitwise-invert-code-code-bitwise-inversion-a}

`~`演算子は、指定された値に対してビット単位の反転 (またはビット単位の NOT) 演算を実行します。指定された値の各ビットを反転します。つまり、0 のビットは 1 になり、1 のビットは 0 になります。

操作の前に、値は 64 ビットに拡張されます。

2 進数`1111000011110000`を例に挙げます。64 ビットに拡張して反転すると、次のようになります。

    Original (16 bits):                                                                 1111000011110000
    Expanded and inverted (64 bits):    1111111111111111111111111111111111111111111111110000111100001111

SQL では、 `~`演算子を次のように使用できます。

```sql
SELECT CONV(~ b'1111000011110000',10,2);
+------------------------------------------------------------------+
| CONV(~ b'1111000011110000',10,2)                                 |
+------------------------------------------------------------------+
| 1111111111111111111111111111111111111111111111110000111100001111 |
+------------------------------------------------------------------+
1 row in set (0.00 sec)
```

結果に`~`演算子を再度適用すると、反転を逆にすることができます。

```sql
SELECT CONV(~ b'1111111111111111111111111111111111111111111111110000111100001111',10,2);
```

    +----------------------------------------------------------------------------------+
    | CONV(~ b'1111111111111111111111111111111111111111111111110000111100001111',10,2) |
    +----------------------------------------------------------------------------------+
    | 1111000011110000                                                                 |
    +----------------------------------------------------------------------------------+
    1 row in set (0.00 sec)

## <a href="https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-or"><code>|</code> (ビットOR)</a> {#a-href-https-dev-mysql-com-doc-refman-8-0-en-bit-functions-html-operator-bitwise-or-code-code-bitwise-or-a}

`|`演算子はビット単位の OR 演算を実行します。2 つの数値の対応するビットを比較します。対応するビットの少なくとも 1 つが 1 の場合、結果の対応するビットは 1 になります。

たとえば、 `1010`と`1100`ビット単位の OR 演算では、 2 つの数値の最初の 3 ビットのうち、対応するビットの少なくとも 1 つが 1 に設定されているため、 `1110`が返されます。

      1010
    | 1100
      ----
      1110

SQL では、 `|`演算子を次のように使用できます。

```sql
SELECT CONV(b'1010' | b'1100',10,2);
```

    +------------------------------+
    | CONV(b'1010' | b'1100',10,2) |
    +------------------------------+
    | 1110                         |
    +------------------------------+
    1 row in set (0.00 sec)

## <a href="https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_bitwise-xor"><code>^</code> (ビット単位の排他的論理和)</a> {#a-href-https-dev-mysql-com-doc-refman-8-0-en-bit-functions-html-operator-bitwise-xor-code-code-bitwise-xor-a}

`^`演算子はビット単位の XOR (排他的論理和) 演算を実行します。2 つの数値の対応するビットを比較します。対応するビットが異なる場合、結果の対応するビットは 1 になります。

たとえば、 `1010`と`1100`ビット単位の XOR 演算では、 2 つの数値の 2 番目と 3 番目のビットが異なるため、 `0110`が返されます。

      1010
    ^ 1100
      ----
      0110

SQL では、 `^`演算子を次のように使用できます。

```sql
SELECT CONV(b'1010' ^ b'1100',10,2);
```

    +------------------------------+
    | CONV(b'1010' ^ b'1100',10,2) |
    +------------------------------+
    | 110                          |
    +------------------------------+
    1 row in set (0.00 sec)

先頭のゼロが削除されているため、結果は`0110`ではなく`110`として表示されることに注意してください。

## <a href="https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_left-shift"><code>&lt;&lt;</code> (左シフト)</a> {#a-href-https-dev-mysql-com-doc-refman-8-0-en-bit-functions-html-operator-left-shift-code-x3c-x3c-code-left-shift-a}

`<<`演算子は左シフト演算を実行し、数値のビットを指定された位置数だけ左にシフトし、右側の空いたビットをゼロで埋めます。

たとえば、次のステートメントでは、 `1<<n`使用して、バイナリ値`1` `n`位置左にシフトします。

```sql
WITH RECURSIVE cte(n) AS (
    SELECT 0 AS n
    UNION ALL
    SELECT 1+n FROM cte WHERE n<10
)
SELECT n,1<<n,LPAD(CONV(1<<n,10,2),11,0) FROM cte;
```

    +------+------+----------------------------+
    | n    | 1<<n | LPAD(CONV(1<<n,10,2),11,0) |
    +------+------+----------------------------+
    |    0 |    1 | 00000000001                |
    |    1 |    2 | 00000000010                |
    |    2 |    4 | 00000000100                |
    |    3 |    8 | 00000001000                |
    |    4 |   16 | 00000010000                |
    |    5 |   32 | 00000100000                |
    |    6 |   64 | 00001000000                |
    |    7 |  128 | 00010000000                |
    |    8 |  256 | 00100000000                |
    |    9 |  512 | 01000000000                |
    |   10 | 1024 | 10000000000                |
    +------+------+----------------------------+
    11 rows in set (0.00 sec)

## <a href="https://dev.mysql.com/doc/refman/8.0/en/bit-functions.html#operator_right-shift"><code>&gt;&gt;</code> (右シフト)</a> {#a-href-https-dev-mysql-com-doc-refman-8-0-en-bit-functions-html-operator-right-shift-code-code-right-shift-a}

`>>`演算子は右シフト演算を実行し、数値のビットを指定された位置数だけ右にシフトし、左側の空いたビットをゼロで埋めます。

たとえば、次のステートメントでは、 `1024>>n`使用して、値`1024` (2 進数では`10000000000` ) を右に`n`位置シフトします。

```sql
WITH RECURSIVE cte(n) AS (
    SELECT 0 AS n
    UNION ALL
    SELECT n+1 FROM cte WHERE n<11
)
SELECT n,1024>>n,LPAD(CONV(1024>>n,10,2),11,0) FROM cte;
```

    +------+---------+-------------------------------+
    | n    | 1024>>n | LPAD(CONV(1024>>n,10,2),11,0) |
    +------+---------+-------------------------------+
    |    0 |    1024 | 10000000000                   |
    |    1 |     512 | 01000000000                   |
    |    2 |     256 | 00100000000                   |
    |    3 |     128 | 00010000000                   |
    |    4 |      64 | 00001000000                   |
    |    5 |      32 | 00000100000                   |
    |    6 |      16 | 00000010000                   |
    |    7 |       8 | 00000001000                   |
    |    8 |       4 | 00000000100                   |
    |    9 |       2 | 00000000010                   |
    |   10 |       1 | 00000000001                   |
    |   11 |       0 | 00000000000                   |
    +------+---------+-------------------------------+
    12 rows in set (0.00 sec)

`>>`演算子は、TiDB [TSO](/tso.md)タイムスタンプから UNIX タイムスタンプを抽出するなど、大きな数値の特定の部分を抽出する場合にも役立ちます。

## MySQL 互換性 {#mysql-compatibility}

MySQL 8.0 と以前のバージョンの MySQL では、ビット関数と演算子の処理にいくつかの違いがあります。TiDB は、MySQL 8.0 の動作に従うことを目指しています。

## 既知の問題 {#known-issues}

以下の場合、TiDB のクエリ結果はMySQL 5.7と同じですが、MySQL 8.0 とは異なります。

-   バイナリ引数を使用したビット演算。詳細については、 [＃30637](https://github.com/pingcap/tidb/issues/30637)参照してください。
-   `BIT_COUNT()`関数の結果。詳細については、 [＃44621](https://github.com/pingcap/tidb/issues/44621)参照してください。

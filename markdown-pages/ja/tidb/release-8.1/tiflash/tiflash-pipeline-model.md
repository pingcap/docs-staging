---
title: TiFlash Pipeline Execution Model
summary: TiFlashパイプライン実行モデルについて学習します。
---

# TiFlashパイプライン実行モデル {#tiflash-pipeline-execution-model}

このドキュメントでは、TiFlashパイプライン実行モデルについて説明します。

v7.2.0 以降、 TiFlash は新しい実行モデルであるパイプライン実行モデルをサポートします。

-   v7.2.0 および v7.3.0 の場合: パイプライン実行モデルは実験的で、 [`tidb_enable_tiflash_pipeline_model`](https://docs.pingcap.com/tidb/v7.2/system-variables#tidb_enable_tiflash_pipeline_model-introduced-since-v720)によって制御されます。
-   v7.4.0 以降のバージョンの場合: パイプライン実行モデルが一般提供されました。これはTiFlashの内部機能であり、 TiFlashリソース制御と緊密に統合されています。TiFlash リソース制御を有効にすると、パイプライン実行モデルが自動的に有効になります。TiFlash リソース制御の使用方法の詳細については、 [リソース制御を使用してリソースの分離を実現する](/tidb-resource-control.md#parameters-for-resource-control)を参照してください。また、v7.4.0 以降では、システム変数`tidb_enable_tiflash_pipeline_model`は非推奨です。

論文[Morsel 駆動型並列処理: マルチコア時代に向けた NUMA 対応クエリ評価フレームワーク](https://dl.acm.org/doi/10.1145/2588555.2610507)にヒントを得て、 TiFlashパイプライン実行モデルは、従来のスレッド スケジューリング モデルとは異なる、きめ細かいタスク スケジューリング モデルを提供します。これにより、オペレーティング システムのスレッド アプリケーションとスケジューリングのオーバーヘッドが削減され、きめ細かいスケジューリング メカニズムが提供されます。

## 設計と実装 {#design-and-implementation}

オリジナルのTiFlashストリーム モデルは、スレッド スケジューリング実行モデルです。各クエリは、複数のスレッドが連携して実行するように独立して適用されます。

スレッド スケジューリング モデルには、次の 2 つの欠陥があります。

-   同時実行性の高いシナリオでは、スレッドが多すぎるとコンテキストスイッチの数が多くなり、スレッドのスケジューリングコストが高くなります。
-   スレッド スケジューリング モデルでは、クエリのリソース使用量を正確に測定したり、きめ細かいリソース制御を行うことはできません。

新しいパイプライン実行モデルでは、次の最適化が行われます。

-   クエリは複数のパイプラインに分割され、順番に実行されます。各パイプラインでは、データ ブロックが可能な限りキャッシュに保持されるため、時間的な局所性が向上し、実行プロセス全体の効率が向上します。
-   オペレーティング システムのネイティブ スレッド スケジューリング モデルを排除し、よりきめ細かいスケジューリング メカニズムを実装するために、各パイプラインは複数のタスクにインスタンス化され、タスク スケジューリング モデルが使用されます。同時に、固定スレッド プールを使用して、オペレーティング システムのスレッド スケジューリングのオーバーヘッドが削減されます。

パイプライン実行モデルのアーキテクチャは次のとおりです。

![TiFlash pipeline execution model design](https://download.pingcap.com/images/docs/tiflash/tiflash-pipeline-model.png)

上の図に示すように、パイプライン実行モデルは、パイプライン クエリ エグゼキュータとタスク スケジューラという 2 つの主要コンポーネントで構成されます。

-   パイプラインクエリエグゼキュータ

    パイプライン クエリ エグゼキュータは、TiDB ノードから送信されたクエリ要求をパイプライン有向非巡回グラフ (DAG) に変換します。

    クエリ内のパイプライン ブレーカー演算子を見つけ、パイプライン ブレーカーに従ってクエリを複数のパイプラインに分割します。次に、パイプライン間の依存関係に従ってパイプラインを DAG に組み立てます。

    パイプライン ブレーカーは、一時停止/ブロッキング ロジックを持つ演算子です。このタイプの演算子は、すべてのデータ ブロックを受信するまで上流演算子から継続的にデータ ブロックを受信し、その後、処理結果を下流演算子に返します。このタイプの演算子はデータ処理パイプラインを中断するため、パイプライン ブレーカーと呼ばれます。パイプライン ブレーカーの 1 つに集計演算子があります。これは、上流演算子のすべてのデータをハッシュ テーブルに書き込んでから、ハッシュ テーブルでデータを計算し、結果を下流演算子に返します。

    クエリがパイプライン DAG に変換された後、パイプライン クエリ エグゼキュータは依存関係に従って各パイプラインを順番に実行します。パイプラインは、クエリの同時実行性に応じて複数のタスクにインスタンス化され、タスク スケジューラに送信されて実行されます。

-   タスクスケジューラ

    タスク スケジューラは、パイプライン クエリ エグゼキュータによって送信されたタスクを実行します。タスクは、さまざまな実行ロジックに従って、タスク スケジューラ内のさまざまなコンポーネント間で動的に切り替えられます。

    -   CPUタスクスレッドプール

        データのフィルタリングや関数の計算など、タスク内で CPU を集中的に使用する計算ロジックを実行します。

    -   IOタスクスレッドプール

        中間結果をディスクに書き込むなど、タスク内で IO 集約型の計算ロジックを実行します。

    -   待機リアクター

        ネットワークレイヤーがデータパケットを計算レイヤーに転送するのを待つなど、タスク内の待機ロジックを実行します。

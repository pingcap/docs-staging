---
title: Tune Operating System Performance
summary: オペレーティング システムのパラメータを調整する方法を学習します。
---

# オペレーティングシステムのパフォーマンスを調整する {#tune-operating-system-performance}

このドキュメントでは、CentOS 7 の各サブシステムをチューニングする方法を紹介します。

> **注記：**
>
> -   CentOS 7 オペレーティング システムのデフォルト構成は、中程度のワークロードで実行されるほとんどのサービスに適しています。特定のサブシステムのパフォーマンスを調整すると、他のサブシステムに悪影響を与える可能性があります。したがって、システムを調整する前に、すべてのユーザー データと構成情報をバックアップしてください。
> -   すべての変更を本番環境に適用する前に、テスト環境で完全にテストします。

## パフォーマンス分析方法 {#performance-analysis-methods}

システム チューニングは、システム パフォーマンス分析の結果に基づいて行う必要があります。このセクションでは、パフォーマンス分析の一般的な方法を示します。

### 60秒で {#in-60-seconds}

[*60,000 ミリ秒での Linux パフォーマンス分析*](http://www.brendangregg.com/Articles/Netflix_Linux_Perf_Analysis_60s.pdf) 、著者 Brendan Gregg と Netflix パフォーマンス エンジニアリング チームによって公開されています。使用されているすべてのツールは、Linux の公式リリースから入手できます。次のリスト項目の出力を分析して、最も一般的なパフォーマンスの問題をトラブルシューティングできます。

-   `uptime`
-   `dmesg | tail`
-   `vmstat 1`
-   `mpstat -P ALL 1`
-   `pidstat 1`
-   `iostat -xz 1`
-   `free -m`
-   `sar -n DEV 1`
-   `sar -n TCP,ETCP 1`
-   `top`

詳しい使用方法については、対応する`man`手順を参照してください。

### パフォーマンス {#perf}

perf は Linux カーネルが提供する重要なパフォーマンス解析ツールであり、ハードウェアレベル (CPU/PMU、パフォーマンス監視ユニット) の機能とソフトウェア機能 (ソフトウェア カウンター、トレース ポイント) をカバーしています。詳細な使用方法については[パフォーマンスの例](http://www.brendangregg.com/perf.html#Background)を参照してください。

### BCC/bpftrace {#bcc-bpftrace}

CentOS 7.6 以降、Linux カーネルは Berkeley Packet Filter (BPF) をサポートしています。したがって、 [60秒で](#in-60-seconds)の結果に基づいて詳細な分析を行うための適切なツールを選択できます。 perf/ftrace と比較すると、BPF はプログラム可能でパフォーマンス オーバーヘッドが少なくなっています。 kprobe と比較すると、BPF はセキュリティが高く、本番環境に適しています。 BCC ツールキットの詳細な使用方法については、 [BPF コンパイラ コレクション (BCC)](https://github.com/iovisor/bcc/blob/master/README.md)を参照してください。

## 性能調整 {#performance-tuning}

このセクションでは、分類されたカーネル サブシステムに基づいたパフォーマンス チューニングについて説明します。

### CPU - 周波数スケーリング {#cpu-frequency-scaling}

cpufreq は、CPU 周波数を動的に調整するモジュールです。5 つのモードをサポートしています。サービスのパフォーマンスを確保するには、パフォーマンス モードを選択し、動的な調整を行わずに、サポートされている最高の動作周波数に CPU 周波数を固定します。この操作のコマンドは`cpupower frequency-set --governor performance`です。

### CPU—割り込みアフィニティ {#cpu-interrupt-affinity}

-   `irqbalance`サービスを通じて自動バランスを実現できます。
-   手動バランス:
    -   割り込みのバランスをとる必要があるデバイスを特定します。CentOS 7.5 以降では、 `be2iscsi`ドライバーと NVMe 設定を使用するデバイスなど、特定のデバイスとそのドライバーに対して最適な割り込みアフィニティがシステムによって自動的に構成されます。このようなデバイスの割り込みアフィニティを手動で構成することはできなくなりました。
    -   その他のデバイスについては、チップのマニュアルを参照して、これらのデバイスが割り込みの分散をサポートしているかどうかを確認してください。
        -   そうでない場合、これらのデバイスのすべての割り込みは同じ CPU にルーティングされ、変更できません。
        -   該当する場合は、 `smp_affinity`マスクを計算し、対応する構成ファイルを設定します。詳細については、 [カーネルドキュメント](https://www.kernel.org/doc/Documentation/IRQ-affinity.txt)を参照してください。

### NUMA CPU バインディング {#numa-cpu-binding}

Non-Uniform Memory Access (NUMA) ノードをまたいでメモリへのアクセスをできるだけ避けるために、スレッドの CPU アフィニティを設定することで、スレッド/プロセスを特定の CPU コアにバインドすることができます。通常のプログラムの場合、CPU バインドには`numactl`コマンドを使用できます。詳細な使用方法については、Linux のマニュアル ページを参照してください。ネットワーク インターフェイス カード (NIC) 割り込みについては、 [ネットワークを調整する](#network-tuning)を参照してください。

### メモリ - 透過的巨大ページ (THP) {#memory-transparent-huge-page-thp}

データベースは連続的なメモリアクセス パターンではなく、散在的なメモリ アクセス パターンを持つことが多いため、データベース アプリケーションに THP を使用することは推奨され**ません**。高レベルのメモリ断片化が深刻な場合は、THP ページが割り当てられるときにレイテンシーが高くなります。THP の直接圧縮を有効にすると、CPU 使用率が急上昇します。したがって、THP を無効にすることをお勧めします。

```shell
echo never > /sys/kernel/mm/transparent_hugepage/enabled
echo never > /sys/kernel/mm/transparent_hugepage/defrag
```

### メモリ - 仮想メモリパラメータ {#memory-virtual-memory-parameters}

-   `dirty_ratio`パーセント比率。ダーティ ページ キャッシュの合計量がシステムメモリ全体のこのパーセント比率に達すると、システムは`pdflush`操作を使用してダーティ ページ キャッシュをディスクに書き込み始めます。デフォルト値の`dirty_ratio`は 20% であり、通常は調整する必要はありません。NVMe デバイスなどの高性能 SSD の場合、この値を下げるとメモリ再利用の効率が向上します。
-   `dirty_background_ratio`パーセント比率。ダーティ ページ キャッシュの合計量がシステムメモリ全体のこのパーセント比率に達すると、システムはバックグラウンドでダーティ ページ キャッシュをディスクに書き込み始めます。デフォルト値の`dirty_background_ratio`は 10% であり、通常は調整する必要はありません。NVMe デバイスなどの高性能 SSD の場合、値を低く設定すると、メモリ再利用の効率が向上します。

### ストレージとファイルシステム {#storage-and-file-system}

コア I/O スタック リンクは長く、ファイル システムレイヤー、ブロック デバイスレイヤー、およびドライバーレイヤーが含まれます。

#### I/Oスケジューラ {#i-o-scheduler}

I/O スケジューラは、storageデバイス上で I/O 操作が実行されるタイミングと期間を決定します。I/O エレベーターとも呼ばれます。SSD デバイスの場合、I/O スケジューリング ポリシーを`noop`に設定することをお勧めします。

```shell
echo noop > /sys/block/${SSD_DEV_NAME}/queue/scheduler
```

#### フォーマットパラメータ - ブロックサイズ {#formatting-parameters-block-size}

ブロックはファイル システムの作業単位です。ブロック サイズによって、1 つのブロックに保存できるデータの量が決まり、これにより、1 回に書き込まれたり読み取られたりするデータの最小量が決まります。

デフォルトのブロック サイズは、ほとんどのシナリオに適しています。ただし、ブロック サイズ (または複数のブロックのサイズ) が、通常毎回読み書きされるデータの量と同じか、わずかに大きい場合、ファイル システムのパフォーマンスが向上し、データstorageの効率が高くなります。小さなファイルでも、ブロック全体が使用されます。ファイルは複数のブロックに分散できますが、これにより実行時のオーバーヘッドが増加します。

`mkfs`コマンドを使用してデバイスをフォーマットする場合は、ファイル システム オプションの一部としてブロック サイズを指定します。ブロック サイズを指定するパラメーターは、ファイル システムによって異なります。詳細については、 `man mkfs.ext4`使用など、対応する`mkfs`マニュアル ページを参照してください。

#### <code>mount</code>パラメータ {#code-mount-code-parameters}

`mount`コマンドで`noatime`オプションが有効になっている場合、ファイルの読み取り時にメタデータの更新が無効になります。 `nodiratime`動作が有効になっている場合、ディレクトリの読み取り時にメタデータの更新が無効になります。

### ネットワークチューニング {#network-tuning}

ネットワーク サブシステムは、敏感な接続を持つさまざまな部分で構成されています。CentOS 7 のネットワーク サブシステムは、ほとんどのワークロードに対して最高のパフォーマンスを提供するように設計されており、これらのワークロードのパフォーマンスを自動的に最適化します。したがって、通常はネットワーク パフォーマンスを手動で調整する必要はありません。

ネットワークの問題は通常、ハードウェアまたは関連デバイスの問題によって発生します。したがって、プロトコル スタックを調整する前に、ハードウェアの問題を排除してください。

ネットワーク スタックは大部分が自己最適化されていますが、ネットワーク パケット処理における次の側面がボトルネックとなり、パフォーマンスに影響を及ぼす可能性があります。

-   NIC ハードウェア キャッシュ: ハードウェア レベルでパケット損失を正しく観察するには、 `ethtool -S ${NIC_DEV_NAME}`コマンドを使用して`drops`フィールドを観察します。パケット損失が発生すると、ハード/ソフト割り込みの処理速度が NIC の受信速度に追いつかない可能性があります。受信バッファ サイズが上限より小さい場合は、パケット損失を回避するために RX バッファを増やすこともできます。クエリ コマンドは`ethtool -g ${NIC_DEV_NAME}` 、変更コマンドは`ethtool -G ${NIC_DEV_NAME}`です。

-   ハードウェア割り込み: NIC が Receive-Side Scaling (RSS、マルチ NIC 受信とも呼ばれる) 機能をサポートしている場合は、 `/proc/interrupts` NIC 割り込みを確認します。割り込みが不均等な場合は、 [CPU - 周波数スケーリング](#cpufrequency-scaling) 、 [CPU—割り込みアフィニティ](#cpuinterrupt-affinity) 、および[NUMA CPU バインディング](#numa-cpu-binding)を参照してください。NIC が RSS をサポートしていない場合、または RSS の数が物理 CPU コアの数よりも大幅に少ない場合は、 Receive Packet Steering (RPS、RSS のソフトウェア実装と見なすことができます) と、RPS 拡張 Receive Flow Steering (RFS) を構成します。詳細な構成については、 [カーネルドキュメント](https://www.kernel.org/doc/Documentation/networking/scaling.txt)を参照してください。

-   ソフトウェア割り込み: `/proc/net/softnet_stat`の監視を観察します。3 列目以外の他の列の値が増加している場合は、 `softirq`の`net.core.netdev_budget`または`net.core.dev_weight`の値を適切に調整して、CPU 時間を増やします。また、CPU 使用率をチェックして、どのタスクが頻繁に CPU を使用しているか、それらを最適化できるかどうかを判断する必要もあります。

-   アプリケーション ソケットの受信キュー: `ss -nmp`の`Resv-q`列を監視します。キューがいっぱいの場合は、アプリケーション ソケット キャッシュのサイズを増やすか、自動キャッシュ調整方法を使用することを検討してください。また、アプリケーションレイヤーのアーキテクチャを最適化し、ソケットの読み取り間隔を短縮できるかどうかも検討してください。

-   イーサネット フロー制御: NIC とスイッチがフロー制御機能をサポートしている場合は、この機能を使用して、カーネルが NIC キュー内のデータを処理するための時間を確保し、NIC バッファ オーバーフローの問題を回避できます。

-   割り込みの統合: ハードウェア割り込みが頻繁すぎるとシステム パフォーマンスが低下し、ハードウェア割り込みが遅すぎるとパケット損失が発生します。新しい NIC は割り込み統合機能をサポートしており、ドライバーがハードウェア割り込みの数を自動的に調整できます。この機能を確認するには`ethtool -c ${NIC_DEV_NAME}`実行し、有効にするには`ethtool -C ${NIC_DEV_NAME}`実行します。アダプティブ モードでは、NIC が割り込み統合を自動的に調整できます。このモードでは、ドライバーがトラフィック モードとカーネル受信モードをチェックし、統合設定をリアルタイムで評価してパケット損失を防止します。異なるブランドの NIC には、異なる機能とデフォルト構成があります。詳細については、NIC のマニュアルを参照してください。

-   アダプタ キュー: プロトコル スタックを処理する前に、カーネルはこのキューを使用して NIC が受信したデータをバッファリングします。各 CPU には独自のバックログ キューがあります。このキューにキャッシュできるパケットの最大数は`netdev_max_backlog`です`/proc/net/softnet_stat`の 2 列目に注目してください。行の 2 列目が増加し続ける場合、CPU [行 1] キューがいっぱいでデータ パケットが失われていることを意味します。この問題を解決するには、 `net.core.netdev_max_backlog`値を 2 倍に増やし続けます。

-   送信キュー: 送信キューの長さの値によって、送信前にキューに入れることができるパケットの数が決まります。デフォルト値は`1000`で、10 Gbps には十分です。ただし、 `ip -s link`の出力から TX エラーの値を確認した場合は、それを 2 倍の`ip link set dev ${NIC_DEV_NAME} txqueuelen 2000`にしてみてください。

-   Driver: NIC ドライバーは通常、チューニング パラメーターを提供します。デバイスのハードウェア マニュアルとそのドライバーのドキュメントを参照してください。

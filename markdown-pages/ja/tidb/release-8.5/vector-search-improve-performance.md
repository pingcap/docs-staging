---
title: Improve Vector Search Performance
summary: TiDB Vector Search のパフォーマンスを向上させるためのベスト プラクティスを学びます。
---

# ベクトル検索のパフォーマンスを向上させる {#improve-vector-search-performance}

TiDB ベクトル検索を使用すると、画像、ドキュメント、またはその他の入力に類似した結果を検索する近似最近傍 (ANN) クエリを実行できます。クエリのパフォーマンスを向上させるには、次のベスト プラクティスを確認してください。

<CustomContent platform="tidb">

> **警告：**
>
> ベクトル検索機能は実験的です。本番環境での使用は推奨されません。この機能は予告なく変更される可能性があります。バグを見つけた場合は、GitHub で[問題](https://github.com/pingcap/tidb/issues)を報告できます。

</CustomContent>

> **注記：**
>
> ベクトル検索機能は、TiDB セルフマネージド クラスターと[TiDB Cloudサーバーレス](https://docs.pingcap.com/tidbcloud/select-cluster-tier#tidb-cloud-serverless)クラスターでのみ使用できます。

## ベクトル列にベクトル検索インデックスを追加する {#add-vector-search-index-for-vector-columns}

[ベクトル検索インデックス](/vector-search-index.md)は、リコール率がわずかに低下するだけのトレードオフで、ベクトル検索クエリのパフォーマンスを通常 10 倍以上大幅に向上させます。

## ベクトルインデックスが完全に構築されていることを確認する {#ensure-vector-indexes-are-fully-built}

大量のベクター データを挿入すると、その一部がデルタレイヤーで永続化を待機している可能性があります。このようなデータのベクトル インデックスは、データが永続化された後に構築されます。すべてのベクター データがインデックス化されるまで、ベクター検索のパフォーマンスは最適ではありません。インデックス構築の進行状況を確認するには、 [インデックス構築の進行状況をビュー](/vector-search-index.md#view-index-build-progress)参照してください。

## ベクトルの次元を減らすか埋め込みを短くする {#reduce-vector-dimensions-or-shorten-embeddings}

ベクトルの次元が大きくなるにつれて、ベクトル検索のインデックス作成とクエリの計算の複雑さが大幅に増加し、より多くの浮動小数点の比較が必要になります。

パフォーマンスを最適化するには、可能な限りベクトル次元を減らすことを検討してください。通常、これには別の埋め込みモデルへの切り替えが必要です。モデルを切り替えるときは、モデルの変更がベクトル クエリの精度に与える影響を評価する必要があります。

OpenAI `text-embedding-3-large`などの特定の埋め込みモデルは[埋め込みの短縮](https://openai.com/index/new-embedding-models-and-api-updates/)サポートしています。これは、埋め込みの概念表現プロパティを失うことなく、ベクトルシーケンスの末尾からいくつかの数字を削除します。このような埋め込みモデルを使用して、ベクトルの次元を削減することもできます。

## 結果からベクター列を除外する {#exclude-vector-columns-from-the-results}

ベクター埋め込みデータは通常大きく、検索プロセス中にのみ使用されます。クエリ結果からベクター列を除外すると、TiDBサーバーと SQL クライアント間で転送されるデータが大幅に削減され、クエリのパフォーマンスが向上します。

ベクター列を除外するには、 `SELECT *`使用してすべての列を取得するのではなく、 `SELECT`句で取得する列を明示的にリストします。

## インデックスをウォームアップする {#warm-up-the-index}

一度も使用されていない、または長期間アクセスされていないインデックスにアクセスする場合 (コールド アクセス)、TiDB はインデックス全体をクラウドstorageまたはディスク (メモリではなく) から読み込む必要があります。このプロセスには時間がかかり、多くの場合、クエリのレイテンシーが長くなります。さらに、長期間 (たとえば、数時間) SQL クエリがない場合、コンピューティング リソースが再利用され、後続のアクセスがコールド アクセスになります。

このようなクエリのレイテンシーを回避するには、実際のワークロードの前に、ベクトル インデックスにヒットする同様のベクトル検索クエリを実行して、インデックスをウォームアップします。
